% IDC_analytic returns an array, and a graph of the IDC curve of % an MMPP given Tmin (minimum window size), and Tlength (the % desired length of the array.  % also the expected # of spikes in a time interval% and the probability generating function for the number of arrivals%The inputs are lambda1, lambda2, trans1,% and trans2.  The algorithm comes from Lucantoni 1986.% lambda1 = nonburst rate% lambda2 = burst rate% trans1 = rate of transition nb-> b% trans2 = rate of transition b -> nbfprintf('enter values for the following\n');l1 = input('lambda1:  ');l2 = input('lambda2:  ');r1 = input('trans1:  ');r2 = input('trans2:  ');Tmin = input('Tmin (in msec):  ');Tlength = input('Tlength:  ');Tarray = Tmin * [1:Tlength];% next section is for pgfPi = 1/(r1+r2) * [r2 r1];e = [1 1]';R = [-r1 r1; r2 -r2];V = [l1 0; 0 l2];IDC_array = zeros(1, Tlength);ExpArray = zeros(1, Tlength);pgf = zeros(1, Tlength);for iwinsize = 1:Tlength	t = (iwinsize * Tmin )/1000; % previously we called this winsize, but it's put in seconds	Anum = 2*(l1 - l2)^2 *r1 *r2;	Adenom = (r1 + r2)^2*(l1*r2 + l2*r1);	Bnum = Anum;	Bdenom = (r1 + r2)^3*(l1*r2 + l2*r1)*t;		A = Anum/Adenom;	B = Bnum/Bdenom;	C = 1 - exp(-(r1+r2)*t);		IDC_array(iwinsize) = 1 + A - ( B * C );	ExpArray(iwinsize) = (l1*r2 +l2*r1)/(r1 +r2) * t;	%pgf = Pi * exp(	endfigure(1), subplot(2,1,1), plot(Tarray, IDC_array),xlabel('Window size (msec)'),ylabel('Index for the dispersion of counts'), title('IDC curve');subplot(2,1,2), plot (Tarray, ExpArray), xlabel('Window size (msec)'), ylabel('Expected number of spikes'), title('Expected number of spikes');